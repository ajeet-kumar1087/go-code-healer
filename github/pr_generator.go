package github

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// GenerateBranchName creates a descriptive branch name for the panic fix
func GenerateBranchName(panicEvent PanicEvent) string {
	// Extract filename from full path
	parts := strings.Split(panicEvent.SourceFile, "/")
	filename := parts[len(parts)-1]

	// Remove file extension
	if idx := strings.LastIndex(filename, "."); idx != -1 {
		filename = filename[:idx]
	}

	// Create branch name with panic context
	branchName := fmt.Sprintf("fix/panic-%s-line-%d", filename, panicEvent.LineNumber)

	// Replace invalid characters
	branchName = strings.ReplaceAll(branchName, " ", "-")
	branchName = strings.ReplaceAll(branchName, "_", "-")
	branchName = strings.ToLower(branchName)

	return branchName
}

// GeneratePRTitle creates a descriptive title for the pull request
func GeneratePRTitle(panicEvent PanicEvent) string {
	parts := strings.Split(panicEvent.SourceFile, "/")
	filename := parts[len(parts)-1]

	return fmt.Sprintf("Fix panic in %s at line %d", filename, panicEvent.LineNumber)
}

// GeneratePRDescription creates a comprehensive description for the pull request
func GeneratePRDescription(panicEvent PanicEvent, fixResponse *FixResponse) string {
	var description strings.Builder

	description.WriteString("## Automatic Panic Fix\n\n")
	description.WriteString("This pull request contains an automatically generated fix for a runtime panic.\n\n")

	description.WriteString("### Panic Details\n")
	description.WriteString(fmt.Sprintf("- **Error**: %s\n", panicEvent.Error))
	description.WriteString(fmt.Sprintf("- **Location**: %s:%d\n", panicEvent.SourceFile, panicEvent.LineNumber))
	description.WriteString(fmt.Sprintf("- **Function**: %s\n", panicEvent.Function))
	description.WriteString(fmt.Sprintf("- **Timestamp**: %s\n\n", panicEvent.Timestamp.Format(time.RFC3339)))

	if fixResponse != nil {
		description.WriteString("### AI-Generated Fix\n")
		description.WriteString(fmt.Sprintf("**Confidence**: %.1f%%\n\n", fixResponse.Confidence*100))
		description.WriteString("**Explanation**:\n")
		description.WriteString(fixResponse.Explanation)
		description.WriteString("\n\n")

		description.WriteString("### Proposed Changes\n")
		description.WriteString("```go\n")
		description.WriteString(fixResponse.ProposedFix)
		description.WriteString("\n```\n\n")
	}

	description.WriteString("### Stack Trace\n")
	description.WriteString("```\n")
	description.WriteString(panicEvent.StackTrace)
	description.WriteString("\n```\n\n")

	description.WriteString("---\n")
	description.WriteString("*This PR was automatically generated by Go Code Healer*")

	return description.String()
}

// CreatePullRequest creates a new branch, commits changes, and opens a PR
func (gc *GitHubAPIClient) CreatePullRequest(ctx context.Context, request PRRequest) error {
	gc.logger.Info("Creating pull request: %s", request.Title)

	// Validate request
	if err := gc.validatePRRequest(request); err != nil {
		return fmt.Errorf("invalid PR request: %w", err)
	}

	// Step 1: Get the default branch SHA
	defaultBranch, err := gc.getDefaultBranch(ctx)
	if err != nil {
		gc.logger.Error("Failed to get default branch: %v", err)
		return fmt.Errorf("failed to get default branch: %w", err)
	}
	gc.logger.Debug("Default branch: %s", defaultBranch)

	baseSHA, err := gc.getBranchSHA(ctx, defaultBranch)
	if err != nil {
		gc.logger.Error("Failed to get base branch SHA: %v", err)
		return fmt.Errorf("failed to get base branch SHA: %w", err)
	}
	gc.logger.Debug("Base SHA: %s", baseSHA)

	// Step 2: Create a new branch
	if err := gc.createBranch(ctx, request.BranchName, baseSHA); err != nil {
		gc.logger.Error("Failed to create branch %s: %v", request.BranchName, err)
		return fmt.Errorf("failed to create branch: %w", err)
	}

	// Step 3: Apply file changes
	for i, change := range request.Changes {
		gc.logger.Debug("Applying change %d/%d: %s", i+1, len(request.Changes), change.FilePath)
		if err := gc.updateFile(ctx, request.BranchName, change); err != nil {
			gc.logger.Error("Failed to update file %s: %v", change.FilePath, err)
			return fmt.Errorf("failed to update file %s: %w", change.FilePath, err)
		}
	}

	// Step 4: Create the pull request
	prResult, err := gc.createPR(ctx, request, defaultBranch)
	if err != nil {
		gc.logger.Error("Failed to create pull request: %v", err)
		return fmt.Errorf("failed to create pull request: %w", err)
	}

	gc.logger.Info("Successfully created pull request #%d: %s", prResult.Number, prResult.URL)
	return nil
}

// validatePRRequest validates the pull request request
func (gc *GitHubAPIClient) validatePRRequest(request PRRequest) error {
	if request.BranchName == "" {
		return fmt.Errorf("branch name is required")
	}
	if request.Title == "" {
		return fmt.Errorf("title is required")
	}
	if len(request.Changes) == 0 {
		return fmt.Errorf("at least one file change is required")
	}
	for i, change := range request.Changes {
		if change.FilePath == "" {
			return fmt.Errorf("file path is required for change %d", i)
		}
		if change.Content == "" {
			return fmt.Errorf("content is required for change %d", i)
		}
	}
	return nil
}

// createPR creates the actual pull request
func (gc *GitHubAPIClient) createPR(ctx context.Context, request PRRequest, baseBranch string) (*PRResult, error) {
	url := fmt.Sprintf("%s/repos/%s/%s/pulls", gc.baseURL, gc.repoOwner, gc.repoName)

	payload := map[string]string{
		"title": request.Title,
		"head":  request.BranchName,
		"base":  baseBranch,
		"body":  request.Description,
	}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "token "+gc.token)
	req.Header.Set("Accept", "application/vnd.github.v3+json")
	req.Header.Set("Content-Type", "application/json")

	resp, err := gc.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		body, _ := io.ReadAll(resp.Body)
		return nil, &GitHubError{
			StatusCode: resp.StatusCode,
			Message:    string(body),
			URL:        url,
		}
	}

	var prResponse struct {
		Number  int    `json:"number"`
		HTMLURL string `json:"html_url"`
		Title   string `json:"title"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&prResponse); err != nil {
		return nil, fmt.Errorf("failed to decode PR response: %w", err)
	}

	result := &PRResult{
		URL:    prResponse.HTMLURL,
		Number: prResponse.Number,
		Title:  prResponse.Title,
	}

	gc.logger.Debug("Created pull request: %s", request.Title)
	return result, nil
}
